# 操作系统小记（二）：内核同步方法

助教在为 Lab 2 引入链表时，完全忽略了其操作的原子性问题，导致 Lab 2 发布的代码存在严重的 Race Condition（竞态条件）漏洞。本文探讨如何在内核中实现有效的同步机制，以避免此类问题的发生。本文参考了《Linux Kernel Development》第三版第 9、10 章的很多内容。

## 情况分析

Lab 2 引入的链表被广泛用于各种内核数据结构中，例如进程管理中的就绪队列和内核线程的创建队列。在 Lab 2 初始发布时，我们仅考虑 Trap 处理过程、`__switch_to` 切换上下文的过程是不可中断的。

## Linux 的同步控制

Linux 内核提供的同步基础设置不再介绍：

- 原子操作
- 锁：
    - 自旋锁（Spinlock）
    - 互斥锁（Mutex）
    - 读写锁（RW Lock）
- [RCU](https://www.kernel.org/doc/html/next/RCU/whatisRCU.html)

我们直接开始分析内核中的同步控制实例。

### Slab

- Create：

    因该操作可能更改 Slab 分配器多层次的数据结构，使用**互斥锁**保护整个操作过程。

    ```c title="mm/slab_common.c"
    struct kmem_cache *__kmem_cache_create_args(const char *name,
            unsigned int object_size,
            struct kmem_cache_args *args,
            slab_flags_t flags)
    {
        mutex_lock(&slab_mutex);
        //...
        goto out_unlock;
    out_unlock:
        mutex_unlock(&slab_mutex);
        return s;
    }
    ```

- Alloc：

    ```c title="mm/slub.c"
    ```





