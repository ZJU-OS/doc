# Lab 4：用户态

!!! danger "DDL"

    本实验尚未发布。

## 实验简介

经过 Lab2（调度）和 Lab3（虚拟内存）的铺垫，我们的内核已经具备了**多任务**和**地址空间隔离**的基本能力。现在，是时候让我们的操作系统迈出关键一步 —— **运行真正的用户态程序**。

然而实现用户态并不容易，本次实验的内容量较大，请同学们合理安排时间。我们需要解决下列问题：

- **如何运行用户态程序？**

    在 Lab1 学习链接器脚本时，我们知道普通应用程序是 ELF 格式的可执行文件。所以我们要**写一个 ELF 加载器**，解析 ELF 文件，并将其加载到用户态进程的地址空间中。

    既然要加载到用户态进程的地址空间，我们还需要**设计用户态程序的内存布局**，包括代码段、数据段、堆栈等。

- **用户态程序如何调用内核服务？**

    在理论课上我们学习了**系统调用**的概念。用户态程序不能直接进行和敏感资源（如硬件设备、内存管理单元等）相关的操作，而是通过系统调用请求内核代为执行。因此，我们需要**进一步增强 `trap_handler()`，实现系统调用机制**，处理来自用户态的 ecall 异常。

## Part 0：准备工作

### 更新代码

现在你位于 `lab3` 分支。你需要创建 `lab4` 分支，合并上游的代码：

```shell
git checkout -b lab4
git fetch upstream
git merge upstream/lab4
```

下面的合并说明供同学们解决合并冲突时参考：

TODO

## Part 1：用户态与内核态的交互

作为本次实验的第一步，我们首先要增强 Trap 处理和 `task_struct` 结构体，为用户态程序和内核态程序的交互打下基础。我们先不管用户态程序是什么样子，从内核的视角出发，设计和实现内核对用户态程序的支持。

### 改进 Trap Handler

经历过前几个实验，同学们应该对进入 Trap 时保存上下文很熟悉了。**系统调用正是利用 ecall 作为一种异常，通过 Trap 上下文与内核传递参数和返回值的**。现在，我们要把以前保存的上下文定义为一个结构体 `struct pt_regs`，方便下一节实现系统调用使用。

```c title="kernel/arch/riscv/include/proc.h"
struct pt_regs {
    uint64_t ra;
    uint64_t sp;
    //...
};
```

### 系统调用

### 内核栈与 sscratch

### Task1：实现系统调用

你的任务是：

1. 改进 `_traps()` 的实现：上下文保存到内核栈栈顶，布局与 `struct pt_regs` 定义一致。

## Part 2：运行用户态程序

### 用户态程序嵌入内核

因为我们还没有实现文件系统，所以无法从磁盘加载用户态程序。待运行的用户态程序被编译为 ELF 格式的二进制文件，嵌入到内核镜像中。请你阅读 `vmlinux.lds`，了解 ELF 格式的用户态程序被嵌在了哪个地方，以便后续实现 ELF 的解析和加载。

### 用户态程序的内存布局

### ELF 加载器

## Part 3：实现系统调用
